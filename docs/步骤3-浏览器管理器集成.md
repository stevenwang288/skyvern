# 步骤3: 浏览器管理器集成

## 概述
修改浏览器管理器，支持根据browser_config参数动态选择浏览器类型，保持与现有功能的向后兼容性。

## 目标文件
`skyvern/webeye/browser_manager.py`

## 实施内容

### 3.1 修改_create_browser_state方法
```python
@staticmethod
async def _create_browser_state(
    proxy_location: ProxyLocation | None = None,
    url: str | None = None,
    task_id: str | None = None,
    workflow_run_id: str | None = None,
    script_id: str | None = None,
    organization_id: str | None = None,
    extra_http_headers: dict[str, str] | None = None,
    browser_address: str | None = None,
    browser_config: BrowserConfig | None = None,  # 新增参数
) -> BrowserState:
    """
    创建浏览器状态实例，支持多种浏览器类型

    Args:
        browser_config: 浏览器配置，决定使用哪种浏览器类型
        ... 其他现有参数保持不变 ...
    """
    pw = await async_playwright().start()

    # 根据browser_config确定浏览器类型
    if browser_config:
        if browser_config.type == BrowserType.ADSPOWER:
            browser_type = "adspower"
        elif browser_config.type == BrowserType.LOCAL_CUSTOM:
            browser_type = "local-custom"
        else:
            # SKYVERN_DEFAULT 使用现有逻辑
            browser_type = "chromium-headful" if SettingsManager.get_settings().BROWSER_TYPE == "headed" else "chromium-headless"
    else:
        # 保持向后兼容，使用原有逻辑
        browser_type = "chromium-headful" if SettingsManager.get_settings().BROWSER_TYPE == "headed" else "chromium-headless"

    # 传递browser_config到browser factory
    kwargs = {
        "proxy_location": proxy_location,
        "extra_http_headers": extra_http_headers,
        "browser_address": browser_address,
        "browser_config": browser_config,  # 传递配置
    }

    browser_context, browser_artifacts, browser_cleanup = await BrowserContextFactory.create_browser_context(
        pw, browser_type=browser_type, **kwargs
    )

    return BrowserState(
        pw,
        browser_context,
        browser_artifacts=browser_artifacts,
        browser_cleanup=browser_cleanup,
    )
```

### 3.2 修改get_or_create_for_task方法
```python
async def get_or_create_for_task(
    self,
    task: Task,
    browser_session_id: str | None = None,
) -> BrowserState:
    """
    为任务获取或创建浏览器状态，支持browser_config
    """
    # ... 现有缓存检查逻辑保持不变 ...

    # 在创建新浏览器状态时传递browser_config
    browser_state = await self._create_browser_state(
        proxy_location=task.proxy_location,
        url=task.url,
        task_id=task.task_id,
        workflow_run_id=task.workflow_run_id,
        organization_id=task.organization_id,
        extra_http_headers=task.extra_http_headers,
        browser_address=task.browser_address,
        browser_config=task.browser_config,  # 传递浏览器配置
    )

    # ... 缓存和返回逻辑保持不变 ...
```

### 3.3 完整的浏览器类型选择逻辑
```python
def determine_browser_type(browser_config: BrowserConfig | None) -> str:
    """
    根据浏览器配置确定浏览器类型

    Args:
        browser_config: 浏览器配置对象

    Returns:
        str: 浏览器类型标识符
    """
    if not browser_config:
        # 向后兼容：使用原有逻辑
        return "chromium-headful" if SettingsManager.get_settings().BROWSER_TYPE == "headed" else "chromium-headless"

    # 根据配置类型选择对应的浏览器实现
    if browser_config.type == BrowserType.ADSPOWER:
        return "adspower"
    elif browser_config.type == BrowserType.LOCAL_CUSTOM:
        return "local-custom"
    else:  # BrowserType.SKYVERN_DEFAULT
        return "chromium-headful" if SettingsManager.get_settings().BROWSER_TYPE == "headed" else "chromium-headless"
```

### 3.4 配置验证和错误处理
```python
def validate_browser_config(browser_config: BrowserConfig | None) -> None:
    """
    验证浏览器配置的有效性

    Args:
        browser_config: 浏览器配置对象

    Raises:
        ValueError: 配置无效时抛出异常
    """
    if not browser_config:
        return

    if browser_config.type == BrowserType.LOCAL_CUSTOM:
        if not browser_config.chrome_path:
            raise ValueError("本地自定义Chrome模式需要提供chrome_path")
        # 验证路径格式但不检查文件是否存在（可能在不同环境中）
        if not isinstance(browser_config.chrome_path, str) or not browser_config.chrome_path.strip():
            raise ValueError("chrome_path必须是有效的字符串路径")

    elif browser_config.type == BrowserType.ADSPOWER:
        if not browser_config.adspower_user_id:
            raise ValueError("AdsPower模式需要提供adspower_user_id")
        if not isinstance(browser_config.adspower_user_id, str) or not browser_config.adspower_user_id.strip():
            raise ValueError("adspower_user_id必须是有效的字符串")
```

### 3.5 增强的错误处理和日志记录
```python
import structlog

LOG = structlog.get_logger()

async def _create_browser_state_with_logging(
    self,
    proxy_location: ProxyLocation | None = None,
    url: str | None = None,
    task_id: str | None = None,
    workflow_run_id: str | None = None,
    script_id: str | None = None,
    organization_id: str | None = None,
    extra_http_headers: dict[str, str] | None = None,
    browser_address: str | None = None,
    browser_config: BrowserConfig | None = None,
) -> BrowserState:
    """
    带日志记录的浏览器状态创建方法
    """
    # 记录浏览器配置信息
    if browser_config:
        LOG.info(
            "创建浏览器状态",
            browser_type=browser_config.type,
            has_chrome_path=bool(browser_config.chrome_path),
            has_adspower_user_id=bool(browser_config.adspower_user_id),
            task_id=task_id,
            workflow_run_id=workflow_run_id
        )
    else:
        LOG.info(
            "创建浏览器状态（默认）",
            browser_type="skyvern_default",
            task_id=task_id,
            workflow_run_id=workflow_run_id
        )

    try:
        # 验证配置
        validate_browser_config(browser_config)

        # 确定浏览器类型
        browser_type = self.determine_browser_type(browser_config)
        LOG.debug("确定的浏览器类型", browser_type=browser_type)

        # 创建浏览器状态
        browser_state = await self._create_browser_state(
            proxy_location=proxy_location,
            url=url,
            task_id=task_id,
            workflow_run_id=workflow_run_id,
            script_id=script_id,
            organization_id=organization_id,
            extra_http_headers=extra_http_headers,
            browser_address=browser_address,
            browser_config=browser_config,
        )

        LOG.info("浏览器状态创建成功", browser_type=browser_type, task_id=task_id)
        return browser_state

    except Exception as e:
        LOG.error(
            "浏览器状态创建失败",
            error=str(e),
            browser_config=browser_config,
            task_id=task_id,
            exc_info=True
        )
        raise
```

## 技术要点

1. **向后兼容**: 未提供browser_config时使用原有逻辑
2. **类型安全**: 明确的浏览器类型判断和转换
3. **配置验证**: 在创建前验证配置的有效性
4. **错误处理**: 完善的异常捕获和日志记录
5. **资源管理**: 确保浏览器状态正确创建和清理

## 集成验证

### 3.6 集成测试代码
```python
async def test_browser_manager_integration():
    """测试浏览器管理器集成功能"""
    from skyvern.forge.sdk.schemas.browser import BrowserConfig, BrowserType

    browser_manager = BrowserManager()

    # 测试1: 默认浏览器（向后兼容）
    browser_state = await browser_manager._create_browser_state()
    assert browser_state is not None
    print("✓ 默认浏览器创建成功")

    # 测试2: Skyvern默认浏览器
    config = BrowserConfig(type=BrowserType.SKYVERN_DEFAULT)
    browser_state = await browser_manager._create_browser_state(browser_config=config)
    assert browser_state is not None
    print("✓ Skyvern默认浏览器创建成功")

    # 测试3: 本地自定义Chrome（路径验证）
    try:
        config = BrowserConfig(
            type=BrowserType.LOCAL_CUSTOM,
            chrome_path="/invalid/path"
        )
        browser_state = await browser_manager._create_browser_state(browser_config=config)
        print("✗ 应该抛出路径无效异常")
    except Exception as e:
        print(f"✓ 正确捕获异常: {e}")

    # 测试4: AdsPower浏览器（需要服务运行）
    try:
        config = BrowserConfig(
            type=BrowserType.ADSPOWER,
            adspower_user_id="test_user"
        )
        browser_state = await browser_manager._create_browser_state(browser_config=config)
        print("✓ AdsPower浏览器创建成功")
    except Exception as e:
        print(f"✓ AdsPower测试（预期可能失败）: {e}")
```

## 验证方法

1. **配置传递**: 确保browser_config正确传递到工厂方法
2. **类型判断**: 验证浏览器类型选择逻辑正确性
3. **错误处理**: 测试各种异常情况的处理
4. **向后兼容**: 确认无配置时的行为与原有逻辑一致
5. **日志记录**: 检查日志输出是否包含关键信息

## 常见问题

1. **配置验证失败**: 检查browser_config字段完整性
2. **浏览器类型不匹配**: 确认BrowserType枚举值正确
3. **工厂方法调用失败**: 验证注册的类型处理器存在
4. **资源清理问题**: 确保cleanup函数正确执行

## 下一步
完成浏览器管理器集成后，进入步骤4：API路由层开发