// ========================= 扩展Skyvern浏览器集成方案 =========================
 这是大模型   https://apis.iflow.cn/v1	sk-2c42e76b6de37e5463bfc72d04812f8f	qwen3-vl-plus
D:\OneDrive\steven\code\1\ads2\local-api-mcp-typescript-main
// ===== 1. 后端Schema扩展 (skyvern/forge/sdk/schemas/browser.py) =====
from enum import StrEnum
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
 
class BrowserType(StrEnum):
    """
    浏览器类型枚举
    - skyvern_default: Skyvern默认浏览器，使用现有的chromium-headless/headful模式
    - local_custom: 本地自定义Chrome，允许用户指定Chrome路径和参数
    - adspower: AdsPower防关联浏览器，企业级反检测解决方案
    """
    SKYVERN_DEFAULT = "skyvern_default"
    LOCAL_CUSTOM = "local_custom" 
    ADSPOWER = "adspower"
 
class BrowserConfig(BaseModel):
    """
    浏览器配置模型，支持多种浏览器类型的统一配置
    """
    type: BrowserType = Field(
        default=BrowserType.SKYVERN_DEFAULT,
        description="浏览器类型，决定使用哪种浏览器创建策略"
    )
    chrome_path: Optional[str] = Field(
        default=None,
        description="本地Chrome执行文件路径，仅在type为local_custom时使用"
    )
    chrome_args: Optional[List[str]] = Field(
        default=None,
        description="Chrome启动参数列表，可用于自定义浏览器行为"
    )
    adspower_user_id: Optional[str] = Field(
        default=None,
        description="AdsPower浏览器用户ID，仅在type为adspower时使用"
    )
    adspower_group_id: Optional[str] = Field(
        default=None,
        description="AdsPower浏览器分组ID，可选"
    )
 
class AdsPowerBrowserInfo(BaseModel):
    """AdsPower浏览器信息模型"""
    user_id: str = Field(description="浏览器用户ID")
    name: str = Field(description="浏览器名称")
    serial_number: str = Field(description="浏览器序列号")
    remark: Optional[str] = Field(default=None, description="备注信息")
    group_id: Optional[str] = Field(default=None, description="分组ID")
    status: str = Field(description="浏览器状态：Active/Inactive")
 
class AdsPowerStatus(BaseModel):
    """AdsPower服务状态模型"""
    available: bool = Field(description="AdsPower服务是否可用")
    message: str = Field(description="状态信息")
    browsers: List[AdsPowerBrowserInfo] = Field(default=[], description="可用浏览器列表")
 
# ===== 2. 任务Schema扩展 (修改 skyvern/forge/sdk/schemas/tasks.py) =====
# 在TaskBase类中添加browser_config字段：
 
class TaskBase(BaseModel):
    # ... 现有字段保持不变 ...
    
    browser_config: Optional[BrowserConfig] = Field(
        default=None,
        description="浏览器配置，指定任务使用的浏览器类型和相关参数"
    )
 
# ===== 3. 浏览器工厂扩展 (修改 skyvern/webeye/browser_factory.py) =====
import asyncio
import aiohttp
import subprocess
import tempfile
import random
import structlog
from pathlib import Path
from typing import Dict, Any, Tuple, Optional
from playwright.async_api import Playwright, BrowserContext, Page
from skyvern.forge.sdk.schemas.browser import BrowserConfig, BrowserType, AdsPowerStatus
 
LOG = structlog.get_logger()
 
class AdsPowerService:
    """
    AdsPower API服务类，负责与AdsPower客户端进行交互
    提供浏览器状态检查、启动、停止等功能
    """
    
    def __init__(self, base_url: str = "http://localhost:50325"):
        self.base_url = base_url
        self.timeout = 30
        
    async def check_status(self) -> AdsPowerStatus:
        """
        检查AdsPower服务状态并获取可用浏览器列表
        
        Returns:
            AdsPowerStatus: 包含服务状态和浏览器列表的对象
        """
        try:
            # 检查AdsPower服务是否运行
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=5)) as session:
                async with session.get(f"{self.base_url}/api/v1/status") as resp:
                    if resp.status != 200:
                        return AdsPowerStatus(
                            available=False,
                            message=f"AdsPower服务响应异常: HTTP {resp.status}",
                            browsers=[]
                        )
                        
                # 获取浏览器列表
                async with session.get(f"{self.base_url}/api/v1/user/list") as resp:
                    browsers_data = await resp.json()
                    
                    if browsers_data.get("code") != 0:
                        return AdsPowerStatus(
                            available=True,
                            message="AdsPower连接正常，但获取浏览器列表失败",
                            browsers=[]
                        )
                    
                    # 转换浏览器数据格式
                    browsers = []
                    for browser_data in browsers_data.get("data", {}).get("list", []):
                        browsers.append(AdsPowerBrowserInfo(
                            user_id=browser_data.get("user_id", ""),
                            name=browser_data.get("name", ""),
                            serial_number=browser_data.get("serial_number", ""),
                            remark=browser_data.get("remark"),
                            group_id=browser_data.get("group_id"),
                            status=browser_data.get("status", "Unknown")
                        ))
                    
                    return AdsPowerStatus(
                        available=True,
                        message=f"AdsPower连接正常，找到 {len(browsers)} 个浏览器",
                        browsers=browsers
                    )
                    
        except asyncio.TimeoutError:
            return AdsPowerStatus(
                available=False,
                message="AdsPower连接超时，请检查客户端是否启动",
                browsers=[]
            )
        except Exception as e:
            LOG.error("检查AdsPower状态失败", error=str(e))
            return AdsPowerStatus(
                available=False,
                message=f"AdsPower客户端未启动或网络异常: {str(e)}",
                browsers=[]
            )
    
    async def start_browser(self, user_id: str) -> Dict[str, Any]:
        """
        启动指定的AdsPower浏览器
        
        Args:
            user_id: AdsPower浏览器用户ID
            
        Returns:
            Dict包含启动结果和连接信息
        """
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=self.timeout)) as session:
                params = {"userId": user_id}
                async with session.get(f"{self.base_url}/api/v1/browser/start", params=params) as resp:
                    result = await resp.json()
                    
                    if result.get("code") != 0:
                        raise Exception(f"AdsPower启动浏览器失败: {result.get('msg', '未知错误')}")
                    
                    # 返回连接信息
                    ws_data = result.get("data", {}).get("ws", {})
                    return {
                        "success": True,
                        "selenium_url": f"http://{ws_data.get('selenium', '')}",
                        "puppeteer_url": f"ws://{ws_data.get('puppeteer', '')}",
                        "user_id": user_id
                    }
                    
        except Exception as e:
            LOG.error("启动AdsPower浏览器失败", user_id=user_id, error=str(e))
            raise Exception(f"启动AdsPower浏览器失败: {str(e)}")
    
    async def stop_browser(self, user_id: str) -> bool:
        """
        停止指定的AdsPower浏览器
        
        Args:
            user_id: AdsPower浏览器用户ID
            
        Returns:
            bool: 是否成功停止
        """
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=10)) as session:
                params = {"userId": user_id}
                async with session.get(f"{self.base_url}/api/v1/browser/stop", params=params) as resp:
                    result = await resp.json()
                    return result.get("code") == 0
        except Exception as e:
            LOG.error("停止AdsPower浏览器失败", user_id=user_id, error=str(e))
            return False
 
async def _create_adspower_browser(
    playwright: Playwright,
    proxy_location: ProxyLocation | None = None,
    extra_http_headers: dict[str, str] | None = None,
    **kwargs: dict,
) -> tuple[BrowserContext, BrowserArtifacts, BrowserCleanupFunc]:
    """
    创建AdsPower防关联浏览器实例
    
    这个函数集成AdsPower API，启动指定的防关联浏览器，并建立CDP连接
    支持代理设置和自定义HTTP头
    
    Args:
        playwright: Playwright实例
        proxy_location: 代理配置（可选）
        extra_http_headers: 额外的HTTP头（可选）
        **kwargs: 其他配置参数，包括browser_config
        
    Returns:
        tuple: (BrowserContext, BrowserArtifacts, cleanup_function)
    """
    browser_config: BrowserConfig = kwargs.get("browser_config")
    if not browser_config or not browser_config.adspower_user_id:
        raise ValueError("AdsPower模式需要提供有效的browser_config.adspower_user_id")
    
    adspower_service = AdsPowerService()
    
    # 检查AdsPower服务状态
    status = await adspower_service.check_status()
    if not status.available:
        raise Exception(f"AdsPower不可用: {status.message}")
    
    LOG.info("启动AdsPower浏览器", user_id=browser_config.adspower_user_id)
    
    try:
        # 启动AdsPower浏览器
        start_result = await adspower_service.start_browser(browser_config.adspower_user_id)
        selenium_url = start_result["selenium_url"]
        
        # 等待浏览器完全启动
        await asyncio.sleep(3)
        
        # 建立CDP连接
        browser = await playwright.chromium.connect_over_cdp(selenium_url)
        
        # 获取或创建浏览器上下文
        contexts = browser.contexts
        if contexts:
            browser_context = contexts[0]
        else:
            browser_context = await browser.new_context(
                proxy=setup_proxy() if proxy_location else None,
                extra_http_headers=extra_http_headers,
            )
        
        # 设置浏览器artifacts
        browser_artifacts = BrowserContextFactory.build_browser_artifacts(**kwargs)
        
        # 设置控制台日志记录
        set_browser_console_log(browser_context, browser_artifacts)
        
        # 设置下载监听器
        set_download_file_listener(browser_context, **kwargs)
        
        # 定义清理函数
        def cleanup_func():
            """清理AdsPower浏览器资源"""
            try:
                # 异步停止AdsPower浏览器
                asyncio.create_task(adspower_service.stop_browser(browser_config.adspower_user_id))
                LOG.info("AdsPower浏览器清理完成", user_id=browser_config.adspower_user_id)
            except Exception as e:
                LOG.error("AdsPower浏览器清理失败", user_id=browser_config.adspower_user_id, error=str(e))
        
        LOG.info("AdsPower浏览器创建成功", user_id=browser_config.adspower_user_id, selenium_url=selenium_url)
        return browser_context, browser_artifacts, cleanup_func
        
    except Exception as e:
        LOG.error("创建AdsPower浏览器失败", user_id=browser_config.adspower_user_id, error=str(e))
        # 确保出错时停止浏览器
        await adspower_service.stop_browser(browser_config.adspower_user_id)
        raise
 
async def _create_local_custom_browser(
    playwright: Playwright,
    proxy_location: ProxyLocation | None = None,
    extra_http_headers: dict[str, str] | None = None,
    **kwargs: dict,
) -> tuple[BrowserContext, BrowserArtifacts, BrowserCleanupFunc]:
    """
    创建本地自定义Chrome浏览器实例
    
    允许用户指定Chrome路径和启动参数，适合需要特定Chrome版本或配置的场景
    
    Args:
        playwright: Playwright实例
        proxy_location: 代理配置（可选）
        extra_http_headers: 额外的HTTP头（可选）
        **kwargs: 其他配置参数，包括browser_config
        
    Returns:
        tuple: (BrowserContext, BrowserArtifacts, cleanup_function)
    """
    browser_config: BrowserConfig = kwargs.get("browser_config")
    if not browser_config or not browser_config.chrome_path:
        raise ValueError("本地自定义Chrome模式需要提供有效的browser_config.chrome_path")
    
    chrome_path = Path(browser_config.chrome_path)
    if not chrome_path.exists():
        raise FileNotFoundError(f"Chrome路径不存在: {chrome_path}")
    
    # 生成随机CDP端口，避免冲突
    cdp_port = random.randint(9222, 9999)
    while _is_port_in_use(cdp_port):
        cdp_port = random.randint(9222, 9999)
    
    # 创建临时用户数据目录
    temp_dir = tempfile.mkdtemp(prefix="skyvern_custom_chrome_")
    
    # 构建Chrome启动参数
    chrome_args = [
        f"--remote-debugging-port={cdp_port}",
        f"--user-data-dir={temp_dir}",
        "--disable-blink-features=AutomationControlled",  # 反自动化检测
        "--disable-web-security",  # 禁用网络安全检查
        "--no-first-run",  # 跳过首次运行
        "--no-default-browser-check",  # 跳过默认浏览器检查
        "--disable-infobars",  # 禁用信息栏
        "--disable-extensions",  # 禁用扩展
        "--disable-dev-shm-usage",  # 禁用/dev/shm使用
        "--no-sandbox",  # 禁用沙箱模式（注意安全性）
    ]
    
    # 添加用户自定义参数
    if browser_config.chrome_args:
        chrome_args.extend(browser_config.chrome_args)
    
    # 添加代理设置
    if proxy_location:
        proxy_config = setup_proxy()
        if proxy_config and proxy_config.get("server"):
            chrome_args.append(f"--proxy-server={proxy_config['server']}")
    
    LOG.info("启动本地Chrome浏览器", 
             chrome_path=str(chrome_path), 
             cdp_port=cdp_port, 
             temp_dir=temp_dir)
    
    try:
        # 启动Chrome进程
        process = subprocess.Popen(
            [str(chrome_path)] + chrome_args,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            # 在Windows上需要CREATE_NEW_PROCESS_GROUP
            creationflags=subprocess.CREATE_NEW_PROCESS_GROUP if hasattr(subprocess, 'CREATE_NEW_PROCESS_GROUP') else 0
        )
        
        cdp_url = f"http://localhost:{cdp_port}"
        
        # 等待Chrome启动完成
        if not await _wait_for_chrome_ready(cdp_url, timeout=30):
            process.terminate()
            raise Exception(f"Chrome启动超时，CDP端口: {cdp_port}")
        
        # 建立CDP连接
        browser = await playwright.chromium.connect_over_cdp(cdp_url)
        
        # 创建浏览器上下文
        browser_context = await browser.new_context(
            extra_http_headers=extra_http_headers,
        )
        
        # 设置浏览器artifacts
        browser_artifacts = BrowserContextFactory.build_browser_artifacts(**kwargs)
        
        # 设置控制台日志记录
        set_browser_console_log(browser_context, browser_artifacts)
        
        # 设置下载监听器
        set_download_file_listener(browser_context, **kwargs)
        
        # 定义清理函数
        def cleanup_func():
            """清理本地Chrome浏览器资源"""
            try:
                # 终止Chrome进程
                if process and process.poll() is None:
                    process.terminate()
                    # 等待进程结束，最多等待5秒
                    try:
                        process.wait(timeout=5)
                    except subprocess.TimeoutExpired:
                        process.kill()  # 强制杀死进程
                
                # 清理临时目录
                import shutil
                shutil.rmtree(temp_dir, ignore_errors=True)
                
                LOG.info("本地Chrome浏览器清理完成", cdp_port=cdp_port, temp_dir=temp_dir)
            except Exception as e:
                LOG.error("本地Chrome浏览器清理失败", error=str(e))
        
        LOG.info("本地Chrome浏览器创建成功", cdp_port=cdp_port, cdp_url=cdp_url)
        return browser_context, browser_artifacts, cleanup_func
        
    except Exception as e:
        LOG.error("创建本地Chrome浏览器失败", error=str(e))
        # 确保出错时清理资源
        if 'process' in locals() and process.poll() is None:
            process.terminate()
        if 'temp_dir' in locals():
            import shutil
            shutil.rmtree(temp_dir, ignore_errors=True)
        raise
 
async def _wait_for_chrome_ready(cdp_url: str, timeout: int = 30) -> bool:
    """
    等待Chrome浏览器CDP接口就绪
    
    Args:
        cdp_url: CDP连接URL
        timeout: 超时时间（秒）
        
    Returns:
        bool: 是否成功连接
    """
    for i in range(timeout):
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(f"{cdp_url}/json/version", timeout=aiohttp.ClientTimeout(total=2)) as resp:
                    if resp.status == 200:
                        LOG.debug("Chrome CDP接口就绪", cdp_url=cdp_url, attempts=i+1)
                        return True
        except Exception:
            pass
        
        await asyncio.sleep(1)
    
    LOG.error("Chrome CDP接口连接超时", cdp_url=cdp_url, timeout=timeout)
    return False
 
# 注册新的浏览器类型到工厂
BrowserContextFactory.register_type("adspower", _create_adspower_browser)
BrowserContextFactory.register_type("local-custom", _create_local_custom_browser)
 
# ===== 4. 浏览器管理器扩展 (修改 skyvern/webeye/browser_manager.py) =====
# 在_create_browser_state方法中添加browser_config支持：
 
@staticmethod
async def _create_browser_state(
    proxy_location: ProxyLocation | None = None,
    url: str | None = None,
    task_id: str | None = None,
    workflow_run_id: str | None = None,
    script_id: str | None = None,
    organization_id: str | None = None,
    extra_http_headers: dict[str, str] | None = None,
    browser_address: str | None = None,
    browser_config: BrowserConfig | None = None,  # 新增参数
) -> BrowserState:
    """
    创建浏览器状态实例，支持多种浏览器类型
    
    Args:
        browser_config: 浏览器配置，决定使用哪种浏览器类型
        ... 其他现有参数保持不变 ...
    """
    pw = await async_playwright().start()
    
    # 根据browser_config确定浏览器类型
    if browser_config:
        if browser_config.type == BrowserType.ADSPOWER:
            browser_type = "adspower"
        elif browser_config.type == BrowserType.LOCAL_CUSTOM:
            browser_type = "local-custom"
        else:
            # SKYVERN_DEFAULT 使用现有逻辑
            browser_type = "chromium-headful" if SettingsManager.get_settings().BROWSER_TYPE == "headed" else "chromium-headless"
    else:
        # 保持向后兼容，使用原有逻辑
        browser_type = "chromium-headful" if SettingsManager.get_settings().BROWSER_TYPE == "headed" else "chromium-headless"
    
    # 传递browser_config到browser factory
    kwargs = {
        "proxy_location": proxy_location,
        "extra_http_headers": extra_http_headers,
        "browser_address": browser_address,
        "browser_config": browser_config,  # 传递配置
    }
    
    browser_context, browser_artifacts, browser_cleanup = await BrowserContextFactory.create_browser_context(
        pw, browser_type=browser_type, **kwargs
    )
    
    return BrowserState(
        pw,
        browser_context,
        browser_artifacts=browser_artifacts,
        browser_cleanup=browser_cleanup,
    )
 
# 修改get_or_create_for_task方法以支持browser_config：
async def get_or_create_for_task(
    self,
    task: Task,
    browser_session_id: str | None = None,
) -> BrowserState:
    """
    为任务获取或创建浏览器状态，支持browser_config
    """
    # ... 现有逻辑保持不变，直到创建新浏览器状态的部分 ...
    
    # 在创建新浏览器状态时传递browser_config
    browser_state = await self._create_browser_state(
        proxy_location=task.proxy_location,
        url=task.url,
        task_id=task.task_id,
        workflow_run_id=task.workflow_run_id,
        organization_id=task.organization_id,
        extra_http_headers=task.extra_http_headers,
        browser_address=task.browser_address,
        browser_config=task.browser_config,  # 传递浏览器配置
    )
    
    # ... 其余逻辑保持不变 ...
 
# ===== 5. API路由扩展 (新建 skyvern/forge/sdk/routes/browser.py) =====
from fastapi import APIRouter, HTTPException, Depends
from skyvern.forge.sdk.schemas.browser import AdsPowerStatus, BrowserConfig
from skyvern.webeye.browser_factory import AdsPowerService
from skyvern.forge.sdk.api.models import validate_api_key
 
router = APIRouter()
 
@router.get("/adspower/status", response_model=AdsPowerStatus)
async def get_adspower_status(
    api_key: str = Depends(validate_api_key)
) -> AdsPowerStatus:
    """
    获取AdsPower服务状态和可用浏览器列表
    
    检查AdsPower客户端是否运行，并返回可用的浏览器配置列表
    用于前端显示可选的防关联浏览器
    
    Returns:
        AdsPowerStatus: 包含服务状态和浏览器列表
    """
    try:
        adspower_service = AdsPowerService()
        status = await adspower_service.check_status()
        return status
    except Exception as e:
        LOG.error("获取AdsPower状态失败", error=str(e))
        raise HTTPException(status_code=500, detail=f"获取AdsPower状态失败: {str(e)}")
 
@router.post("/validate-chrome-path")
async def validate_chrome_path(
    chrome_path: str,
    api_key: str = Depends(validate_api_key)
) -> dict:
    """
    验证Chrome路径是否有效
    
    Args:
        chrome_path: Chrome执行文件路径
        
    Returns:
        dict: 包含验证结果的字典
    """
    try:
        path = Path(chrome_path)
        is_valid = path.exists() and path.is_file()
        
        return {
            "valid": is_valid,
            "message": "Chrome路径有效" if is_valid else "Chrome路径无效或文件不存在",
            "path": str(path.absolute()) if is_valid else None
        }
    except Exception as e:
        return {
            "valid": False,
            "message": f"路径验证失败: {str(e)}",
            "path": None
        }
 
# ===== 6. 前端类型定义 (skyvern-frontend/src/api/types.ts) =====
// 在现有types.ts文件中添加以下类型定义：
 
export enum BrowserType {
  SkyvernDefault = "skyvern_default",
  LocalCustom = "local_custom", 
  AdsPower = "adspower"
}
 
export interface BrowserConfig {
  type: BrowserType;
  chrome_path?: string;
  chrome_args?: string[];
  adspower_user_id?: string;
  adspower_group_id?: string;
}
 
export interface AdsPowerBrowserInfo {
  user_id: string;
  name: string;
  serial_number: string;
  remark?: string;
  group_id?: string;
  status: string;
}
 
export interface AdsPowerStatus {
  available: boolean;
  message: string;
  browsers: AdsPowerBrowserInfo[];
}
 
// 扩展CreateTaskRequest接口
export interface CreateTaskRequest {
  // ... 现有字段保持不变 ...
  browser_config?: BrowserConfig;
}
 
// ===== 7. 前端API客户端 (skyvern-frontend/src/api/AxiosClient.ts) =====
// 在现有AxiosClient中添加以下方法：
 
export const getAdsPowerStatus = async (): Promise<AdsPowerStatus> => {
  const response = await client.get<AdsPowerStatus>('/browser/adspower/status');
  return response.data;
};
 
export const validateChromePath = async (chromePath: string): Promise<{valid: boolean; message: string; path?: string}> => {
  const response = await client.post('/browser/validate-chrome-path', { chrome_path: chromePath });
  return response.data;
};
 
// ===== 8. 前端浏览器选择器组件 (skyvern-frontend/src/components/BrowserSelector.tsx) =====
import React, { useState, useEffect } from 'react';
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { Control, useWatch } from 'react-hook-form';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "./ui/select";
import { Input } from "./ui/input";
import { Button } from "./ui/button";
import { Alert, AlertDescription } from "./ui/alert";
import { FormField, FormItem, FormLabel, FormControl, FormMessage, FormDescription } from "./ui/form";
import { RefreshCw, ExternalLink, CheckCircle, XCircle, Chrome, Shield, Zap } from "lucide-react";
import { BrowserType, BrowserConfig, AdsPowerStatus } from "../api/types";
import { getAdsPowerStatus, validateChromePath } from "../api/AxiosClient";
 
interface BrowserSelectorProps {
  control: Control<any>;
  name?: string;
}
 
export function BrowserSelector({ control, name = "browser_config" }: BrowserSelectorProps) {
  const queryClient = useQueryClient();
  
  // 监听表单字段变化
  const watchedConfig = useWatch({
    control,
    name,
    defaultValue: { type: BrowserType.SkyvernDefault }
  }) as BrowserConfig;
 
  const browserType = watchedConfig?.type || BrowserType.SkyvernDefault;
  const chromePath = watchedConfig?.chrome_path || "";
  const adsPowerUserId = watchedConfig?.adspower_user_id || "";
 
  // AdsPower状态查询
  const { 
    data: adsPowerStatus, 
    isLoading: isCheckingAdsPower, 
    refetch: refetchAdsPower 
  } = useQuery({
    queryKey: ["adspower-status"],
    queryFn: getAdsPowerStatus,
    enabled: browserType === BrowserType.AdsPower,
    refetchInterval: 15000, // 15秒自动刷新
    staleTime: 10000,
    retry: 1
  });
 
  // Chrome路径验证查询
  const { 
    data: chromeValidation,
    isLoading: isValidatingChrome 
  } = useQuery({
    queryKey: ["chrome-path-validation", chromePath],
    queryFn: () => validateChromePath(chromePath),
    enabled: browserType === BrowserType.LocalCustom && chromePath.length > 5,
    staleTime: 30000
  });
 
  // 打开AdsPower客户端
  const openAdsPowerClient = () => {
    try {
      // 尝试使用自定义协议打开
      window.open('adspower://', '_blank');
    } catch {
      // 降级到官网下载页面
      window.open('https://www.adspower.com/download', '_blank');
    }
  };
 
  // 浏览器类型选项配置
  const browserTypeOptions = [
    {
      value: BrowserType.SkyvernDefault,
      label: "🤖 Skyvern默认浏览器",
      description: "推荐选项，稳定可靠，自动管理",
      icon: <Zap className="w-4 h-4" />
    },
    {
      value: BrowserType.LocalCustom,
      label: "🌐 本地自定义Chrome",
      description: "使用本地Chrome，支持大窗口和自定义参数",
      icon: <Chrome className="w-4 h-4" />
    },
    {
      value: BrowserType.AdsPower,
      label: "🛡️ AdsPower防关联浏览器",
      description: "企业级反检测，适合敏感业务场景",
      icon: <Shield className="w-4 h-4" />
    }
  ];
 
  return (
    <div className="space-y-6">
      {/* 浏览器类型选择 */}
      <FormField
        control={control}
        name={`${name}.type`}
        render={({ field }) => (
          <FormItem>
            <FormLabel>
              <div className="flex flex-col space-y-1">
                <h3 className="text-lg font-medium">浏览器类型</h3>
                <p className="text-sm text-muted-foreground">
                  选择任务执行时使用的浏览器环境
                </p>
              </div>
            </FormLabel>
            <FormControl>
              <Select value={field.value} onValueChange={field.onChange}>
                <SelectTrigger className="w-full">
                  <SelectValue placeholder="选择浏览器类型" />
                </SelectTrigger>
                <SelectContent>
                  {browserTypeOptions.map((option) => (
                    <SelectItem key={option.value} value={option.value}>
                      <div className="flex items-start space-x-3 py-2">
                        {option.icon}
                        <div className="flex flex-col">
                          <span className="font-medium">{option.label}</span>
                          <span className="text-xs text-muted-foreground">
                            {option.description}
                          </span>
                        </div>
                      </div>
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />
 
      {/* 本地Chrome配置面板 */}
      {browserType === BrowserType.LocalCustom && (
        <div className="border rounded-lg p-4 bg-blue-50/50 space-y-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2">
              <Chrome className="w-5 h-5 text-blue-600" />
              <h4 className="text-lg font-medium">本地Chrome配置</h4>
            </div>
            {chromeValidation && (
              <div className="flex items-center space-x-1">
                {chromeValidation.valid ? (
                  <>
                    <CheckCircle className="w-4 h-4 text-green-500" />
                    <span className="text-sm text-green-600">路径有效</span>
                  </>
                ) : (
                  <>
                    <XCircle className="w-4 h-4 text-red-500" />
                    <span className="text-sm text-red-600">路径无效</span>
                  </>
                )}
              </div>
            )}
          </div>
 
          <FormField
            control={control}
            name={`${name}.chrome_path`}
            render={({ field }) => (
              <FormItem>
                <FormLabel>Chrome执行文件路径 *</FormLabel>
                <FormControl>
                  <Input
                    {...field}
                    placeholder="C:\Program Files\Google\Chrome\Application\chrome.exe"
                    className={chromeValidation?.valid === false ? "border-red-300" : ""}
                  />
                </FormControl>
                <FormDescription>
                  <div className="text-sm space-y-1">
                    <p>常见路径参考：</p>
                    <ul className="list-disc list-inside space-y-0.5 text-xs">
                      <li><strong>Windows:</strong> C:\Program Files\Google\Chrome\Application\chrome.exe</li>
                      <li><strong>macOS:</strong> /Applications/Google Chrome.app/Contents/MacOS/Google Chrome</li>
                      <li><strong>Linux:</strong> /usr/bin/google-chrome</li>
                    </ul>
                  </div>
                </FormDescription>
                <FormMessage />
              </FormItem>
            )}
          />
 
          <FormField
            control={control}
            name={`${name}.chrome_args`}
            render={({ field }) => (
              <FormItem>
                <FormLabel>Chrome启动参数（可选）</FormLabel>
                <FormControl>
                  <Input
                    {...field}
                    value={Array.isArray(field.value) ? field.value.join(' ') : field.value || ''}
                    onChange={(e) => {
                      const args = e.target.value ? e.target.value.split(' ').filter(Boolean) : [];
                      field.onChange(args);
                    }}
                    placeholder="--window-size=1920,1080 --start-maximized"
                  />
                </FormControl>
                <FormDescription>
                  用空格分隔多个参数，例如: --window-size=1920,1080 --start-maximized
                </FormDescription>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>
      )}
 
      {/* AdsPower配置面板 */}
      {browserType === BrowserType.AdsPower && (
        <div className="border rounded-lg p-4 bg-green-50/50 space-y-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2">
              <Shield className="w-5 h-5 text-green-600" />
              <h4 className="text-lg font-medium">AdsPower防关联浏览器</h4>
            </div>
            <div className="flex items-center space-x-2">
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={() => refetchAdsPower()}
                disabled={isCheckingAdsPower}
              >
                <RefreshCw className={`w-4 h-4 mr-1 ${isCheckingAdsPower ? 'animate-spin' : ''}`} />
                刷新
              </Button>
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={openAdsPowerClient}
              >
                <ExternalLink className="w-4 h-4 mr-1" />
                打开AdsPower
              </Button>
            </div>
          </div>
 
          {/* AdsPower服务状态 */}
          {adsPowerStatus && (
            <Alert className={`${
              adsPowerStatus.available 
                ? 'border-green-200 bg-green-50' 
                : 'border-red-200 bg-red-50'
            }`}>
              <div className="flex items-start space-x-2">
                {adsPowerStatus.available ? (
                  <CheckCircle className="w-4 h-4 text-green-500 mt-0.5" />
                ) : (
                  <XCircle className="w-4 h-4 text-red-500 mt-0.5" />
                )}
                <div className="flex-1">
                  <AlertDescription className={
                    adsPowerStatus.available ? 'text-green-700' : 'text-red-700'
                  }>
                    {adsPowerStatus.message}
                    {!adsPowerStatus.available && (
                      <div className="text-sm mt-2 space-y-1">
                        <p>请确保：</p>
                        <ul className="list-disc list-inside text-xs space-y-0.5">
                          <li>AdsPower客户端已启动并登录</li>
                          <li>API接口端口50325未被占用</li>
                          <li>防火墙允许本地连接</li>
                        </ul>
                      </div>
                    )}
                  </AlertDescription>
                </div>
              </div>
            </Alert>
          )}
 
          {/* 浏览器选择 */}
          {isCheckingAdsPower ? (
            <div className="text-center py-8">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-green-600 mx-auto"></div>
              <p className="text-sm text-muted-foreground mt-3">正在检测AdsPower连接状态...</p>
            </div>
          ) : adsPowerStatus?.available ? (
            <FormField
              control={control}
              name={`${name}.adspower_user_id`}
              render={({ field }) => (
                <FormItem>
                  <FormLabel>选择AdsPower浏览器 *</FormLabel>
                  <FormControl>
                    <Select value={field.value} onValueChange={field.onChange}>
                      <SelectTrigger>
                        <SelectValue 
                          placeholder={
                            adsPowerStatus.browsers?.length === 0 
                              ? "未找到可用浏览器，请先在AdsPower中创建" 
                              : "选择一个浏览器配置"
                          } 
                        />
                      </SelectTrigger>
                      <SelectContent>
                        {adsPowerStatus.browsers?.map((browser) => (
                          <SelectItem key={browser.user_id} value={browser.user_id}>
                            <div className="flex flex-col py-1">
                              <div className="flex items-center space-x-2">
                                <Shield className="w-3 h-3 text-green-500" />
                                <span className="font-medium">{browser.name}</span>
                                <span className={`text-xs px-1.5 py-0.5 rounded ${
                                  browser.status === 'Active' 
                                    ? 'bg-green-100 text-green-700' 
                                    : 'bg-gray-100 text-gray-600'
                                }`}>
                                  {browser.status}
                                </span>
                              </div>
                              <div className="text-xs text-muted-foreground mt-1">
                                ID: {browser.user_id} | 序列号: {browser.serial_number}
                                {browser.remark && ` | ${browser.remark}`}
                              </div>
                            </div>
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </FormControl>
                  <FormDescription>
                    {adsPowerStatus.browsers?.length === 0 ? (
                      <span className="text-amber-600">
                        请先在AdsPower客户端中创建浏览器配置
                      </span>
                    ) : (
                      `找到 ${adsPowerStatus.browsers?.length} 个可用浏览器配置`
                    )}
                  </FormDescription>
                  <FormMessage />
                </FormItem>
              )}
            />
          ) : (
            <div className="text-center py-8">
              <Shield className="w-12 h-12 text-gray-400 mx-auto mb-4" />
              <p className="text-muted-foreground">请启动AdsPower客户端后重试</p>
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={openAdsPowerClient}
                className="mt-3"
              >
                <ExternalLink className="w-4 h-4 mr-1" />
                下载AdsPower
              </Button>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
 
// ===== 9. 任务创建表单集成示例 =====
// 在任务创建表单中使用BrowserSelector组件：
 
import { BrowserSelector } from '../components/BrowserSelector';
import { BrowserType } from '../api/types';
 
// 在表单schema中添加browser_config字段：
const taskFormSchema = z.object({
  // ... 现有字段 ...
  browser_config: z.object({
    type: z.nativeEnum(BrowserType).default(BrowserType.SkyvernDefault),
    chrome_path: z.string().optional(),
    chrome_args: z.array(z.string()).optional(),
    adspower_user_id: z.string().optional(),
    adspower_group_id: z.string().optional(),
  }).optional(),
});
 
// 在表单组件中：
function TaskCreateForm() {
  const form = useForm({
    resolver: zodResolver(taskFormSchema),
    defaultValues: {
      // ... 现有默认值 ...
      browser_config: {
        type: BrowserType.SkyvernDefault
      }
    }
  });
 
  return (
    <Form {...form}>
      {/* ... 其他表单字段 ... */}
      
      <BrowserSelector control={form.control} name="browser_config" />
      
      {/* ... 提交按钮等 ... */}
    </Form>
  );
}