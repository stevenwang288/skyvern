# 步骤2: 浏览器工厂模式扩展

## 概述
实现浏览器工厂模式，支持创建不同类型的浏览器实例，包括AdsPower防关联浏览器和本地自定义Chrome。

## 目标文件
`skyvern/webeye/browser_factory.py`

## 实施内容

### 2.1 AdsPower服务类实现
```python
import asyncio
import aiohttp
import structlog
from typing import Dict, Any

LOG = structlog.get_logger()

class AdsPowerService:
    """
    AdsPower API服务类，负责与AdsPower客户端进行交互
    提供浏览器状态检查、启动、停止等功能
    """

    def __init__(self, base_url: str = "http://localhost:50325"):
        self.base_url = base_url
        self.timeout = 30

    async def check_status(self) -> AdsPowerStatus:
        """检查AdsPower服务状态并获取可用浏览器列表"""
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=5)) as session:
                # 检查服务状态
                async with session.get(f"{self.base_url}/api/v1/status") as resp:
                    if resp.status != 200:
                        return AdsPowerStatus(
                            available=False,
                            message=f"AdsPower服务响应异常: HTTP {resp.status}",
                            browsers=[]
                        )

                # 获取浏览器列表
                async with session.get(f"{self.base_url}/api/v1/user/list") as resp:
                    browsers_data = await resp.json()
                    browsers = []
                    for browser_data in browsers_data.get("data", {}).get("list", []):
                        browsers.append(AdsPowerBrowserInfo(
                            user_id=browser_data.get("user_id", ""),
                            name=browser_data.get("name", ""),
                            serial_number=browser_data.get("serial_number", ""),
                            remark=browser_data.get("remark"),
                            group_id=browser_data.get("group_id"),
                            status=browser_data.get("status", "Unknown")
                        ))

                    return AdsPowerStatus(
                        available=True,
                        message=f"AdsPower连接正常，找到 {len(browsers)} 个浏览器",
                        browsers=browsers
                    )
        except Exception as e:
            LOG.error("检查AdsPower状态失败", error=str(e))
            return AdsPowerStatus(
                available=False,
                message=f"AdsPower客户端未启动或网络异常: {str(e)}",
                browsers=[]
            )
```

### 2.2 AdsPower浏览器创建函数
```python
async def _create_adspower_browser(
    playwright: Playwright,
    proxy_location: ProxyLocation | None = None,
    extra_http_headers: dict[str, str] | None = None,
    **kwargs: dict,
) -> tuple[BrowserContext, BrowserArtifacts, BrowserCleanupFunc]:
    """
    创建AdsPower防关联浏览器实例

    Args:
        playwright: Playwright实例
        proxy_location: 代理配置（可选）
        extra_http_headers: 额外的HTTP头（可选）
        **kwargs: 其他配置参数，包括browser_config

    Returns:
        tuple: (BrowserContext, BrowserArtifacts, cleanup_function)
    """
    browser_config: BrowserConfig = kwargs.get("browser_config")
    if not browser_config or not browser_config.adspower_user_id:
        raise ValueError("AdsPower模式需要提供有效的browser_config.adspower_user_id")

    adspower_service = AdsPowerService()

    # 检查AdsPower服务状态
    status = await adspower_service.check_status()
    if not status.available:
        raise Exception(f"AdsPower不可用: {status.message}")

    LOG.info("启动AdsPower浏览器", user_id=browser_config.adspower_user_id)

    try:
        # 启动AdsPower浏览器
        start_result = await adspower_service.start_browser(browser_config.adspower_user_id)
        selenium_url = start_result["selenium_url"]

        # 等待浏览器完全启动
        await asyncio.sleep(3)

        # 建立CDP连接
        browser = await playwright.chromium.connect_over_cdp(selenium_url)

        # 获取或创建浏览器上下文
        contexts = browser.contexts
        if contexts:
            browser_context = contexts[0]
        else:
            browser_context = await browser.new_context(
                proxy=setup_proxy() if proxy_location else None,
                extra_http_headers=extra_http_headers,
            )

        # 设置浏览器artifacts
        browser_artifacts = BrowserContextFactory.build_browser_artifacts(**kwargs)

        # 设置控制台日志记录
        set_browser_console_log(browser_context, browser_artifacts)

        # 设置下载监听器
        set_download_file_listener(browser_context, **kwargs)

        # 定义清理函数
        def cleanup_func():
            """清理AdsPower浏览器资源"""
            try:
                asyncio.create_task(adspower_service.stop_browser(browser_config.adspower_user_id))
                LOG.info("AdsPower浏览器清理完成", user_id=browser_config.adspower_user_id)
            except Exception as e:
                LOG.error("AdsPower浏览器清理失败", user_id=browser_config.adspower_user_id, error=str(e))

        LOG.info("AdsPower浏览器创建成功", user_id=browser_config.adspower_user_id, selenium_url=selenium_url)
        return browser_context, browser_artifacts, cleanup_func

    except Exception as e:
        LOG.error("创建AdsPower浏览器失败", user_id=browser_config.adspower_user_id, error=str(e))
        # 确保出错时停止浏览器
        await adspower_service.stop_browser(browser_config.adspower_user_id)
        raise
```

### 2.3 本地自定义Chrome创建函数
```python
import subprocess
import tempfile
import random
from pathlib import Path

async def _create_local_custom_browser(
    playwright: Playwright,
    proxy_location: ProxyLocation | None = None,
    extra_http_headers: dict[str, str] | None = None,
    **kwargs: dict,
) -> tuple[BrowserContext, BrowserArtifacts, BrowserCleanupFunc]:
    """
    创建本地自定义Chrome浏览器实例

    允许用户指定Chrome路径和启动参数，适合需要特定Chrome版本或配置的场景
    """
    browser_config: BrowserConfig = kwargs.get("browser_config")
    if not browser_config or not browser_config.chrome_path:
        raise ValueError("本地自定义Chrome模式需要提供有效的browser_config.chrome_path")

    chrome_path = Path(browser_config.chrome_path)
    if not chrome_path.exists():
        raise FileNotFoundError(f"Chrome路径不存在: {chrome_path}")

    # 生成随机CDP端口，避免冲突
    cdp_port = random.randint(9222, 9999)
    while _is_port_in_use(cdp_port):
        cdp_port = random.randint(9222, 9999)

    # 创建临时用户数据目录
    temp_dir = tempfile.mkdtemp(prefix="skyvern_custom_chrome_")

    # 构建Chrome启动参数
    chrome_args = [
        f"--remote-debugging-port={cdp_port}",
        f"--user-data-dir={temp_dir}",
        "--disable-blink-features=AutomationControlled",  # 反自动化检测
        "--disable-web-security",  # 禁用网络安全检查
        "--no-first-run",  # 跳过首次运行
        "--no-default-browser-check",  # 跳过默认浏览器检查
        "--disable-infobars",  # 禁用信息栏
        "--disable-extensions",  # 禁用扩展
        "--disable-dev-shm-usage",  # 禁用/dev/shm使用
        "--no-sandbox",  # 禁用沙箱模式（注意安全性）
    ]

    # 添加用户自定义参数
    if browser_config.chrome_args:
        chrome_args.extend(browser_config.chrome_args)

    LOG.info("启动本地Chrome浏览器",
             chrome_path=str(chrome_path),
             cdp_port=cdp_port,
             temp_dir=temp_dir)

    try:
        # 启动Chrome进程
        process = subprocess.Popen(
            [str(chrome_path)] + chrome_args,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            creationflags=subprocess.CREATE_NEW_PROCESS_GROUP if hasattr(subprocess, 'CREATE_NEW_PROCESS_GROUP') else 0
        )

        cdp_url = f"http://localhost:{cdp_port}"

        # 等待Chrome启动完成
        if not await _wait_for_chrome_ready(cdp_url, timeout=30):
            process.terminate()
            raise Exception(f"Chrome启动超时，CDP端口: {cdp_port}")

        # 建立CDP连接
        browser = await playwright.chromium.connect_over_cdp(cdp_url)

        # 创建浏览器上下文
        browser_context = await browser.new_context(
            extra_http_headers=extra_http_headers,
        )

        # 设置浏览器artifacts
        browser_artifacts = BrowserContextFactory.build_browser_artifacts(**kwargs)

        # 设置控制台日志记录
        set_browser_console_log(browser_context, browser_artifacts)

        # 设置下载监听器
        set_download_file_listener(browser_context, **kwargs)

        # 定义清理函数
        def cleanup_func():
            """清理本地Chrome浏览器资源"""
            try:
                # 终止Chrome进程
                if process and process.poll() is None:
                    process.terminate()
                    try:
                        process.wait(timeout=5)
                    except subprocess.TimeoutExpired:
                        process.kill()

                # 清理临时目录
                import shutil
                shutil.rmtree(temp_dir, ignore_errors=True)

                LOG.info("本地Chrome浏览器清理完成", cdp_port=cdp_port, temp_dir=temp_dir)
            except Exception as e:
                LOG.error("本地Chrome浏览器清理失败", error=str(e))

        LOG.info("本地Chrome浏览器创建成功", cdp_port=cdp_port, cdp_url=cdp_url)
        return browser_context, browser_artifacts, cleanup_func

    except Exception as e:
        LOG.error("创建本地Chrome浏览器失败", error=str(e))
        # 确保出错时清理资源
        if 'process' in locals() and process.poll() is None:
            process.terminate()
        if 'temp_dir' in locals():
            import shutil
            shutil.rmtree(temp_dir, ignore_errors=True)
        raise
```

### 2.4 注册新浏览器类型
```python
# 注册新的浏览器类型到工厂
BrowserContextFactory.register_type("adspower", _create_adspower_browser)
BrowserContextFactory.register_type("local-custom", _create_local_custom_browser)
```

## 技术要点

1. **异步编程**: 使用async/await处理I/O操作
2. **错误处理**: 完善的异常捕获和资源清理
3. **资源管理**: 自动清理临时文件和进程
4. **端口管理**: 动态分配CDP端口避免冲突
5. **代理支持**: 集成现有的代理配置

## 验证方法

1. AdsPower服务连接测试
2. 本地Chrome路径验证
3. CDP连接建立测试
4. 浏览器上下文创建
5. 清理函数执行验证

## 下一步
完成浏览器工厂扩展后，进入步骤3：浏览器管理器集成